\documentclass[12pt,a4paper]{article}
\usepackage{times}
\usepackage{durhampaper}
\usepackage{harvard}
\usepackage{underscore}
\usepackage{graphicx}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

%\package save trees - to save room

\citationmode{abbr}
\bibliographystyle{agsm}

\title{Procedural World Building in Roguelike Games}
\author{Benjamin Jones}
\student{Benjamin Jones}
\supervisor{Dr. Tom Friedetzky}
\degree{MSci Natural Sciences}


\begin{document}

\maketitle

\begin{abstract}

{\bf Context/Background}

Procedural content generation in videogames has seen a surge in popularity in recent years. However as game development progress, users expect more and more intelligent and engaging game level design and as a result, investigating new, interesting methods of procedural content generation is vital to keeping end users happy.

{\bf Aims}

This project aims to draw comparisons between current methods of procedural content generation in a roguelike game environment and build upon them to create different and exciting methods of level design. The implementation will focus on creating a number of novel algorithms alongside an intelligent method of evaluating their suitability. 

{\bf Method}

A variety of algorithms will be developed and implemented by building on and combining various existing methods found in existing roguelikes and more sophisticated modern games. Perlin and Simplex noise algorithms will be used to generate the initial random seed, which will then be modified by a variety of methods including the Cellular Automata approach and the use of geometric space-filling curves such as the Hilbert curve and Sierpinski curve. The effectiveness of these will then be evaluated by a custom heuristic, ensuring the quality of the resulting world. 

{\bf Proposed Solution}

The proposed game will be built and played in Java using the JFrame and asciipanel libraries as a framework. The combination of existing algorithms and novel techniques will produce multiple potential procedurally generated worlds, which will be evaluated by the program and the best fit will form the playable environment in a roguelike game. 

\end{abstract}

\begin{keywords}
Procedural content generation, roguelike, world building, noise algorithms, artificial intelligence, heuristic, space-filling algorithms.
\end{keywords}

\section{Introduction}
\subsection{Roguelike Games} \label{ssec:rogue}


The term Roguelike stems from the original 1980s UNIX dungeon crawler `Rogue' created by Michael Toy and Glenn Wichman, giving birth to hundreds of games such as Nethack and Angband that follow the same style and structure and revolutionising the gaming industry as we know it today \cite{Dunhack}. There are many different styles of roguelikes these days, but most share the same core features: turn-based gameplay, procedurally generated tile-based dungeons and randomly created monsters and items [cite PCGBOOK?]. 

The basic premise of the game has the player controlling a single character through numerous ASCII represented dungeons filled with items, monsters and traps[cite roguebasin?]. However what made it so unique and revolutionary at the time was the fact that the game was different every time you played it thanks to its procedurally generated nature. 



\subsection{Procedural Content Generation} \label{ssec:PCG}

% Procedural content generation
% many applications
% process of creation of content through the use of random numbers as the seed to generate objects rather than by hand
% code is used
% grown popular recently
% as they get better they'll be able to open the world up to many great benefits, arbitrary size & complexity
% imagine a world where..
% recent examples
% minecraft is by far the most popular, with .... sales exceeding.. 
% 	demonstrates the capability and potential of successful procedural content generation
% spore
% no man's sky
% krieger 
% 	less well known but still an excellent example of how pgc can be used and an excellent example of its benefits

Procedural content generation (PCG) is the process of creating content through the use of random numbers as seeds to generate objects using code and mathematical functions, as opposed to the typical method of being manually created by a developer[possible citation of a paper]. This has many possible applications, from running real-world simulations on procedurally generated objects and environments \cite{vast}, to generating interesting and unique textures[cite] texture generation, and of course for use in video games. This is typically achieved by modifying the results of mathematical noise algorithms \cite{pgcbookch4}, which generate heightmaps and intensity maps that can be transformed into random terrains. \\

% with popular games such as Minecraft making good use of the Perlin noise algorithm (discussed in more detail in [REF]), 

% The benefits of PCG over manual content creation in video games are clear: game environments with arbitrary size \& complexity can be created in seconds, with the

Procedural generation has many advantages unrivalled by other generation methods: it is typically much faster to evaluate, it can generate arbitrarily complex and intricate designs on the fly and has particularly low memory footprint \cite{surveyPNF}. Additionally, the variation of input parameters can easily generate an incredible number of uniquely styled designs. The result is that procedurally generated game content has the capability to offer every game user a unique gaming experience every time they play. \\

% ref paper \cite{surveyPNF}
% %Procedural noise has many advantages: it is typically very
% fast to evaluate, often allowing evaluation of complex and
% intricate patterns on-the-fly, and it has a very low memory
% footprint, making it an ideal candidate for compactly generating
% complex visual detail. In addition, with a suitable set of
% parameters, procedural noise can be used to easily generate a
% large number of different patterns. Finally, procedural noise
% is often randomly accessible, so that it can be evaluated independently
% at every point in constant time.

A perfect example of the power and potential of PCG is Minecraft. At the time of writing, Minecraft sales have hit more than 70 million world-wide, making it one of the most popular games of all time [reference- help?]. However at it's base, Minecraft draws many parallels with the methods of generation seen in even some of the earliest Roguelike games, for example, Minecraft uses at it's core a 3D adaptation of the 2D Perlin noise algorithm adopted by many popular roguelikes[cite notch], including Nethack and Dwarf Fortress[cite twice].\\

Also recently hitting the spotlights recently is indie game \emph{`No Man's Sky'}, a futuristic sci-fi role-playing game (RPG) that procedurally generates an entire galaxy populated with up to 18 quintillion planets for the player to explore at their leisure. Developed by a team of only 10 people, No Man's Sky demonstrates the power and potential that procedural generation has to offer to the gaming market. \\

A final game worth mentioning is award-winning 2004 German 3D shooter `.kkrieger'. The game won its award not because of its content however, but because its extensive use of procedural generation techniques mean everything from the textures to the in-game sounds (as well as the traditional monsters and levels) are generated completely procedurally. This allows the entire game to be coded in just 96 kilobytes of memory, meaning that even screenshots of the game take up more room than the game itself and allowing .kkrieger to take up to 3000x less storage than an equivalent conventionally designed game \cite{kkrieger}. This game exemplifies what can be achieved using procedural techniques.\\

As games get more complex and take longer to build, coming up with new and exciting ways to programatically generate game content could be the key to a revolution in the gaming industry (expected to reach \$103bn in 2017 \cite{newzoo}).




% \subsection{Evaluation of Literature}

% DRAFT PARAGRAPH
% In a project such as this, it is important to note that the amount of academic research in this area is limited and (one presumes) much of it is being undertaken by private game companies 
% A lot of the current research and experimentation is being undertaken by bloggers and home enthusiasts


\subsection{Project Aims}

The purpose of the project in summary is to investigate the various ways procedural generation is used to generate game environments, and then design and build one or more variants based on the best of these approaches with the aim to create exciting, interesting and challenging environments for a roguelike game setting. The project will also aim to evaluate the output of the algorithms with a fitness heuristic function to identify whether or not a generated output meets these aims. \\

The deliverable should be an executable program running in the Java programming language that is capable of producing two dimensional ASCII worlds for a player to explore. The algorithm should be deterministic, and ideally will be efficient such that it is capable of producing and evaluating multiple worlds quickly, identifying the best and putting that forward to the playable game environment. The game world should have the additional constraint that all parts of the map should be traversable from any other part of the map, explicitly checked by the algorithm. 
%any other constraints



%introduction still needs: Perlin noise, Cellular Automata, maze generation and puzzle generation.  

\subsection{Deliverables}


Please note: unfamiliar concepts introduced here will be discussed later in the design section.

\textbf{Minimum objectives:}

\begin{itemize}%\itemsep0pt

	\item Produce a basic game engine in Java to handle user input and ASCII grid output, to enable world creation and character movement, including side scrolling.
	\item Choose appropriate data structures.
	\item Implement a deterministic 2D noise generator to produce fundamental basis for procedural dungeon creation.
	\item Implement a smoothing function based on the Cellular Automata approach to produce a basis for a cave-like structure.
	\item Implement a probability density field for the placement of walls and floor based upon a mathematical space filling function and a noise generator. 
\end{itemize}
\textbf{Intermediate objectives:}
\begin{itemize}
	\item Develop probability density algorithm to produce interesting and varied worlds based upon various mathematical functions.
	\item Produce a metadata structure for the world that has extra information about each grid space, including items and other features.
	\item Look at potential effects of using more complex noise algorithms (eg Perlin \& Simplex) in world creation.
	\item Be able to check that a world is connected.
\end{itemize}
\textbf{Advanced objectives:}
\begin{itemize}
	
	\item Develop world evaluation heuristic capable of rating worlds on a number of criteria.
	\item Look into maze generation algorithms and underlay them in the world.
	\item Investigate possibility of procedurally generated dungeon `puzzle' rooms.
	\item Optimisation of procedural generation techniques such that generation is fast enough to quickly generate multiple worlds and select the most suitable using the world evaluation heuristic. 
\end{itemize}


\section{Design}

\subsection{Requirements}

\begin{table}[h!]
\centering
\begin{tabular}{l|l|l}
\textbf{ID}  & \textbf{Requirement}                                           & \textbf{Priority} \\ \hline
FR1 & Implementation of fundamental game engine in Java handling IO    & High     \\
FR2 & Implementation of rudimentary noise algorithm                         & High     \\
FR3 & Create Cellular Automata style algorithm for noise smoothing     & High     \\
FR4 & Create probability density algorithm to determine block identity & High     \\
FR5 & Created worlds must have the connected property    			   & Medium    \\
FR6 & Produce metadata structure for grid space                        & Medium   \\
FR7 & Produce world fitness heuristic                                  & Medium  \\ \hline
% \end{tabular}
% \end{table}

% \begin{table}
% \centering
% \begin{tabular}{l|l|l}
% ID  & Non-Functional Requirement                                           & Priority \\ 
% \hline
NFR1 & Optimisation of space filling function in probability density algorithm    & Medium    \\
NFR2 & Improvement of noise algorithm using Perlin approach & High \\
NFR3 & Ability to produce interesting worlds with definable features & High \\
NFR4 & Ability to test for world connectivity            & Medium     \\
NFR5 & Additional game areas involving maze/puzzle generation & Low \\  

\end{tabular}
\caption{Functional \& Non-Functional Requirements}

\label{table:1}
\end{table}

\subsection{Specification of Software}

The implementation of the project will be achieved in Java (SE 1.8). There are a number of reasons why Java is well suited to this project. Java is a well established, high-level language used by millions of people all over the world and as such there are many previous implementations and libraries specific to Roguelikes in Java from which the project can benefit. By utilising copyright free libraries and examples from previous roguelike enthusiasts, a quick framework for the game engine can be easily created and ammended to the project's aims, while focussing development on more important and interesting aspects of the implementation. To this extent, many suitable libraries exist. In particular, we will make extensive use of the `JFrame' and `asciipanel' libraries. The former is a well known library enabling the use of a windowed frame for which the program is able to handle input and output, and the latter a `Java Console System Interface', which is popular among roguelikes and allows for ASCII text character output in various colours. \\

Java is also particularly useful due to its highly object-orientated nature. Since the design aspect of the game can be separated into many parts, it is helpful to be able to abstract and separate each process into different classes, allowing the main focus of the algorithmic side of the project to be apart from the engine handling input and output to the console. This makes development much easier, as well as improving bug fixing and code readability.\\

In addition, Java is known as a platform-neutral language \cite{java}, meaning the final implementation will be easily run on almost any platform (except mobile) without the need to recompile the source. This is very powerful and makes it easy to continue development and evaluation from a variety of computers during the project, especially in the event that additional processing power is preferred later on to run and evaluate multiple simulations of the design algorithms. [POTENTIALLY REMOVE PARAGRAPH] \\

Finally, Java has been chosen because of its familiarity. While the project may benefit from features of other languages (such as the rapid prototyping and clear code of Python), familiarity with Java enables a reduced implementation period in the system development life cycle, allowing more time to be spent on the design, planning and evaluation aspects of the cycle. 
\\

The `Agile' software development approach will be used in the project in order to meet its aims. This is because the project will benefit from achieving each functional target in individual rapid sprint cycles, which can then be thoroughly tested for quality between cycles before the next implementation aspect is introduced. This also enables a higher degree of freedom than other software development approaches (such as the `Waterfall' approach), enabling the constant evaluation and possible change of separate requirements should the fulfillment of previous ones require so, due to the unpredictable nature of certain algorithms effectiveness and ease of implementation.


\subsection{System Design}

The game engine that houses the game world and handles input and output as mentioned will primarily use the asciipanel library, but also follow from an open source implementation created by an online roguelike programmer known as `Trystan' \cite{trystan}. This provides a framework that is able to be modified for the purposes of this project, in order to focus on more complex aspects of the procedural generation algorithmic design. The capabilities of the resulting game engine allow for an interactive window of a similar quality to that of estabilished roguelikes such as Nethack and even Dwarf Fortress. 


\begin{figure}[h]
\begin{minipage}{.5\textwidth}
  \centering
 	\includegraphics[width=6.25cm,height=4cm]{images/asciipanel1inv.png}
	\caption[]{Asciipanel GUI example \\ Image sourced from: \\http://www.headchant.com/2012/02/15/asciipanel-as/}
	\label{fig:fig1}
\end{minipage}
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=6.25cm, height=4cm]{images/nethack2.png}
  \caption[]{Nethack GUI example [probably copyright]}
  \label{fig:fig2}
\end{minipage}
\end{figure}
%Ask for Friedetzky's help


\subsection{Noise and Smoothing Algorithms}
\label{subsec:noise}

Noise algorithms are crucial to most procedurally generated content and will feature heavily in the project as they form the foundation for the world. The noise environment can then be moulded by a number of different approaches to form the basis of the map. \\

There are a few kinds of noise algorithm, from very basic noise algorithms where each `pixel' has an equal chance to be filled or unfilled, to much more advanced versions such as Perlin noise and Simplex noise \cite{textmodel}\cite{improvepnoise}. The type of noise algorithm selected depends on the project requirements, and the sort of algorithm that will aim to transform the noise environment into a playable, enjoyable world. 

The psuedocode for a basic binary noise algorithm described in FR2 (Table:\ref{table:1}) is shown in algorithm \ref{Alg:alg1} below:

\begin{algorithm}
	\For{$x$ \textless $map width$}{
		\For{$y$ \textless  $map height$}{
			\If{$tile[x][y]$= psuedo_random_number() \textless 0.5}{
				$tile[x][y]$ = $floor$
			}
			\Else{
				$tile[x][y]$ = $wall$
			}
		}
	}
	\caption{Basic binary noise production}
	\label{Alg:alg1}
\end{algorithm}

\subsection{Cellular Automata}

The binary noise algorithm is simple and easy to implement, paving the foundation for a smoothing technique known as `Cellular Automata'. This technique became famous in the 1970's when British mathematician John Horton Conway devised his evolutionary `Game of Life', a game that transforms an initial state of `cells' into intricate and interesting patterns and designs by the use of 4 rules \cite{cellauto}: 

\begin{itemize}
	\item Survivals: Every cell with two or three neighbouring cells survives for the next generation.
	\item Deaths. Each cell with four or more neighbours dies (is removed) from overpopulation. Every cell with one neighbor or none dies from isolation.
	\item Births. Each empty cell adjacent to exactly three neighbours--no more, no fewer--is a birth cell. A cell is placed on it at the next move.
\end{itemize}

This process is used upon the result of the binary noise algorithm to `smooth' out the landscape by turning areas that are mostly neighbouring walls into walls and areas mostly neighbouring floors into floors. The process is then repeated a number of times until the desired combination of walls and floors is achieved. The algorithm pseudo code is too long and complicated to be included here, but more details can be found in chapter 7 of Daniel Shiffman's book, `The Nature of Code' (2012). [UNNECESSARY?]\\

An example of the process run on the basic noise algorithm seen in algorithm \ref{Alg:alg1} is shown below:

\begin{figure}[h]
  \centering
 	\includegraphics[scale=0.5]{images/cellauto.png}
	\caption[]{Cellular Automata cave smoothing. The numbers indicate the iterations of the algorithm, where the top-left image is before the smoothing process}
	\label{fig:fig3}
\end{figure}

It's clear to see from figure \ref{fig:fig3} that this process very quickly converges to produce interesting, procedurally generated cave-like structures for a roguelike game setting, in addition to being computationally inexpensive (the generation is instantaneous even for very high levels of iterations (1000+) on a moderately powerful machine). \\

It is, however, limited in its usefulness by itself, as the results of the algorithm are inconsistent, occasionally producing uninteresting or unnatural worlds. Worse still, its particularly prone to what is known as `the isolated cave problem', whereby produced maps are often `disconnected'- that is the player is unable to advance from any location to any other location. 

This nature (seen in fig \ref{fig:fig3}) breaks functional requirement 5 of the project, and therefore alternative methods or amendments must be implemented to achieve this goal. There are a variety of ways that we may achieve this. One approach for example would be to generate many worlds and test for completeness, discarding the worlds that don't fit our criteria. Because of the instantaneous nature of this method of world population, we are able to create and evaluate many worlds very quickly, however the problem arises when we wish to expand our world size. A larger world boundary results in an increased statistical probability that the created world will be disjoint almost every time. An alternative approach would be to identify disjoint sections and connect them up by removing wall segments. This does guarantee connectivity, but is also prone to making the world look unnatural, defeating the point of using the algorithm in the first place. 

One of the biggest advantages with Cellular Automata however is that rules can be tweaked easily to enhance the output. By experimenting with these rules, previous adopters of this approach have been able to produce vastly different environments, some of which are much less likely than others to form disjointed caves \cite{roguebasin}. 




\subsection{Perlin Noise Algorithm}

% [UNFINISHIED] The approach above is good up until a point, but ..... 
% -can only go so far
% -is only so interesting
% -not complex
% -not easy to add complexity 
% -another way to do this might be to use another algorithm - perlin noise
% PLAN
% -go on this
% % http://www.nolithius.com/game-development/world-generation-breakdown
% -space filling curves over the top
% -combination of results to produce probability density algorithm 

% -then just evaluation and finished! 



The approach above is a good starting point for the project but even with the finest tweaking of the algorithms rules, the output is limited by its ability to only produce binary maps (only walls and floors) and its inability to create specific features or structures procedurally, falling short of our non-functional requirement 3. With this aim in mind, we look to a different noise producing algorithm, Perlin noise, to advance upon this requirement. 


Perlin noise was developed by Ken Perlin in 1985 and has been widely used in applications ranging from procedural world generations to computer graphics \cite{imagesynth} \cite{surveyPNF}. It is particularly good for creating natural looking textures in games and simulated environments, and could be adapted for use in a roguelike setting.

It should be noted at this point that Perlin noise is not without flaws and Perlin himself noted a number of improvements on his original design in his 2002 paper, `Improving Noise' \cite{improvepnoise}[UNCESSARY CITATION??]. The resulting improvements will be discussed in a later section[REFERENCE], however Perlin noise is still useful because it is both simpler to implement and the effect of its inefficiencies are questionable in this project. The project aims to quantify these at a later date.

% Perlin noise is generated by first starting with a 2-dimensional grid array where every value in the array may only take on a binary value, generated at random with equal chance of a 0 or 1. This very basic array of noise is the starting point for our Cellular Automata approach (discussed later in section ???).  

% Perlin noise is generated in short by creating a number of 2-dimensional `smooth noise' arrays, known as octaves, each with different levels of smoothness.

% A Perlin noise generator can be split into two components, a noise generator, and an interpolater. In short, the noise generator generates many different 2-dimensional arrays (octaves) at different levels of smoothness (frequency). The interpolator then smoothly 


%  The Perlin algorithm then generates many of these 2-dimensional arrays at different frequencies, known as  These  
% , which are then averaged using an interpolation function to produce the final output. 

% -psuedocode
% -how would it be used in my implementation? 
% 	-form basis of a probability density grid which translates into fill or no fill on ascii grid

Perlin noise generation can be split into two components, a noise generating function, and an interpolation function. The noise generating function operates in a similar fashion to the binary noise generator described in section \ref{subsec:noise}, except instead of taking on either 0 or 1, the function generates floating point numbers between 0 and 1. 


\begin{figure}[h]
  \centering
 	\includegraphics[scale=0.5]{images/figure_2.png}
	\caption[]{Example 1-dimensional noise function. A random value is assigned to each point on the X axis.}
	\label{fig:fig4}
\end{figure}
\begin{figure}[h]
  \centering
 	\includegraphics[scale=0.5]{images/figure_1.png}
	\caption[]{By smoothly interpolating between the values, we obtain a continuous function.}
	\label{fig:fig5}
\end{figure}




% \subsection{Hilbert Curve \& Space Filling Curves}

% Procedural content has many benefits over manual game design...
% Applications in other fields
% Specific kinds of traditional roguelike algorithms
% Possible extensions


% Generally speaking, procedural generation is the creation of content according to the parameters of an algorithm rather than through manual creation by hand. In even simpler terms, it’s the process of creating content using nothing but code.

% In the context of video games, “content” can refer to a wide range of things: sound effects, music tracks, art textures, object models, world terrain, enemy placement, character advancement, and more.

% The key to these procedural algorithms is that they often include some element of randomness. Doing so ensures that a handful of input parameters can generate a wide variety of output results, which can help increase a game’s replayability since the content will be different on each play through.


% DELIVERABLES


% FUNCTIONAL / NON FUNCTIONAL REQUIREMENTS

% then design




% \section{Random stuff}

% Since Rogue came out in 1980, thousands of games have followed the same style and genre. Rogue is a dungeon crawler created in the 1980’s that revolutionised the gaming industry, giving birth to an entire class of video games known today as “roguelikes”. They vary in many ways, but the underlying focus of them all is procedural generation- the concept of algorithmically generating a completely random world every time the game is played. This allows for infinite playability and complexity, and has many different interesting methods of execution \cite{Dunhack}. 
% This project will focus on researching, designing and implementing one or more novel methods of procedural generation, with the aim to create exciting, interesting and challenging environments for a roguelike game setting. 

% The project will evaluate traditional methods of world building from well-known traditional roguelike games such as Nethack, Dwarf Fortress and Rogue, as well as popular recent games such as Minecraft, Spore and Galak-z, and aim to implement improvements on their approach . 

\section{Design}

This section presents the proposed solutions of the problems in detail. The design details should all be placed in this section. You may create a number of subsections, each focusing on one issue.

This section should be up to 8 pages in length.
The rest of this section shows the formats of subsections as well as some general formatting information.  You should also consult the Word template.

\subsection{Main Text}

The font used for the main text should be Times New Roman (Times) and the font size should be 12.  \textbf{The first line of all paragraphs should be indented by 0.25in, \emph{except} for the first paragraph of each section, subsection, subsubsection etc.} (the paragraph immediately after the header) where no indentation is needed.

\subsection{Figures and Tables}
In general, figures and tables should not appear before they are cited.  Place figure captions below the figures; place table titles above the tables.  If your figure has two parts, for example, include the labels ``(a)'' and ``(b)'' as part of the artwork.  Please verify that figures and tables you mention in the text actually exist.  make sure that all tables and figures are numbered as shown in Table  and Figure 1.
sort out your own preferred means of inserting figures

% \begin{table}[htb]
% \centering
% \caption{UNITS FOR MAGNETIC PROPERTIES}
% \vspace*{6pt}
% \begin{tabular}{ccc}\hline\hline
% Symbol & Quantity & Conversion from Gaussian \\ \hline
% \end{tabular}
% \label{units}
% \end{table}

\subsection{References}

The list of cited references should appear at the end of the report, ordered alphabetically by the surnames of the first authors.  The default style for references cited in the main text is the  Harvard (author, date) format.  When citing a section in a book, please give the relevant page numbers, as in.  When citing, where there are either one or two authors, use the names, but if there are more than two, give the first one and use ``et al.'' as in  , except where this would be ambiguous, in which case use all author names.

You need to give all authors' names in each reference.  Do not use ``et al.'' unless there are more than five authors.  Papers that have not been published should be cited as ``unpublished''.  Papers that have been submitted or accepted for publication should be cited as ``submitted for publication'' as in.  You can also cite using just the year when the author's name appears in the text, as in ``but according to Futher , we \dots''.  Where an authors has more than one publication in a year, add `a', `b' etc. after the year.




\bibliography{bib}


\end{document}